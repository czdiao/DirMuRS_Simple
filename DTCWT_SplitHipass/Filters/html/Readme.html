
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Filters</title><meta name="generator" content="MATLAB 8.3"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2015-03-30"><meta name="DC.source" content="Readme.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>Filters</h1><!--introduction--><p><i><b>Author: Chenzhe Diao</b></i></p><p>Implementation of Dual Tree filters and help functions to construct filters, including 2D filters constructed by tensor product structure.</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Data Structure of filters</a></li><li><a href="#2">1D Haar Filter</a></li><li><a href="#3">CQF</a></li><li><a href="#4">Convolution of 2 1D filters</a></li><li><a href="#5">1D Dual Tree Filter Banks</a></li><li><a href="#10">Generate 2D Filter/Filter Bank by Tensor Product</a></li><li><a href="#13">2D Dual Tree Filter Banks</a></li><li><a href="#15">2D Dual Tree Split Highpass Filter Banks</a></li></ul></div><h2>Data Structure of filters<a name="1"></a></h2><div><ul><li>1D Filter:</li></ul></div><pre>     filter1d.filter   :  array of filter
     filter1d.start_pt :  filter array starting point</pre><div><ul><li>2D Filter:</li></ul></div><pre>     filter2d.row_filter:    array of row filter
     filter2d.col_filter:    array of col filter
     filter2d.row_start_pt:  row filter array starting point
     filter2d.col_start_pt:  col filter array starting point</pre><div><ul><li>Filter Bank</li></ul></div><pre>   Implemented as an array of filers:  [lowpass, highpass1, highpass2, ...].
   We always put lowpass at the first.</pre><pre>     1x(s+1) struct array with fields:</pre><pre>         filter
         start_pt</pre><pre>     1x(s+1) struct array with fields:</pre><pre>         row_filter
         row_start_pt
         col_filter
         col_start_pt</pre><h2>1D Haar Filter<a name="2"></a></h2><pre class="codeinput">[HaarLow, HaarHigh] = Haar1d
</pre><pre class="codeoutput">
HaarLow = 

      filter: [0.5000 0.5000]
    start_pt: 0


HaarHigh = 

      filter: [-0.5000 0.5000]
    start_pt: 0

</pre><h2>CQF<a name="3"></a></h2><p>Generate highpass filter from lowpass filter in CQF pair.</p><p><img src="Readme_eq92899.png" alt="$$b_n = (-1)^{n+1} a_{1-n}$$"></p><pre class="codeinput">HaarHigh = CQF(HaarLow)
</pre><pre class="codeoutput">
HaarHigh = 

      filter: [-0.5000 0.5000]
    start_pt: 0

</pre><h2>Convolution of 2 1D filters<a name="4"></a></h2><pre class="codeinput">f = convfilter1d( HaarLow, HaarHigh )
</pre><pre class="codeoutput">
f = 

    start_pt: 0
      filter: [-0.2500 0 0.2500]

</pre><h2>1D Dual Tree Filter Banks<a name="5"></a></h2><p>The Filter Banks given by Selesnick</p><div><ol><li>FirstStageFilter1d.m</li><li>FirstStageFilterShift1d.m</li><li>Tree1Filter1d.m</li><li>Tree2Filter1d.m</li></ol></div><div><ul><li>First Stage Filter Bank for Tree 1:</li></ul></div><pre class="codeinput">FS_Filter = FirstStageFilter1d;
lowpass = FS_Filter(1)
highpass = FS_Filter(2)
</pre><pre class="codeoutput">
lowpass = 

      filter: [-0.0625 0.0625 0.4921 0.4921 0.0625 -0.0625 0.0079 0.0079]
    start_pt: -3


highpass = 

      filter: [0.0079 -0.0079 -0.0625 -0.0625 0.4921 -0.4921 0.0625 0.0625]
    start_pt: -3

</pre><div><ul><li>First Stage Filter Bank for Tree 2. The lowpass is a shifted version of Tree 1.</li></ul></div><pre class="codeinput">FS_Filter2 = FirstStageFilterShift1d;
lowpass = FS_Filter2(1)
highpass = FS_Filter2(2)
</pre><pre class="codeoutput">
lowpass = 

      filter: [-0.0625 0.0625 0.4921 0.4921 0.0625 -0.0625 0.0079 0.0079]
    start_pt: -2


highpass = 

      filter: [-0.0079 0.0079 0.0625 0.0625 -0.4921 0.4921 -0.0625 -0.0625]
    start_pt: -4

</pre><div><ul><li>Later filter bank for Tree 1:</li></ul></div><pre class="codeinput">Filter1 = Tree1Filter1d;
lowpass = Filter1(1)
highpass = Filter1(2)
</pre><pre class="codeoutput">
lowpass = 

      filter: [0.0249 0 -0.0625 0.1654 0.5376 0.4154 0 -0.0808]
    start_pt: -4


highpass = 

      filter: [0.0808 0 -0.4154 0.5376 -0.1654 -0.0625 0 0.0249]
    start_pt: -2

</pre><div><ul><li>Later filter bank for Tree 2:</li></ul></div><pre class="codeinput">Filter2 = Tree2Filter1d;
lowpass = Filter2(1)
highpass = Filter2(2)
</pre><pre class="codeoutput">
lowpass = 

      filter: [-0.0808 0 0.4154 0.5376 0.1654 -0.0625 0 0.0249]
    start_pt: -2


highpass = 

      filter: [-0.0249 0 0.0625 0.1654 -0.5376 0.4154 0 -0.0808]
    start_pt: -4

</pre><h2>Generate 2D Filter/Filter Bank by Tensor Product<a name="10"></a></h2><div><ol><li>FilterTensor.m</li><li>FilterTensorMultiple.m</li></ol></div><div><ul><li>Generate a 2D filter with 2 1D filters</li></ul></div><pre class="codeinput">[RowFilter, ColFilter] = Haar1d;
filter2d = FilterTensor( RowFilter, ColFilter )
</pre><pre class="codeoutput">
filter2d = 

      row_filter: [0.5000 0.5000]
    row_start_pt: 0
      col_filter: [-0.5000 0.5000]
    col_start_pt: 0

</pre><div><ul><li>Generate 2D filter bank with 2 1D filter banks</li></ul></div><pre class="codeinput">RowFilterBank = Tree1Filter1d;
ColFilterBank = Tree2Filter1d;
FilterBank2d = FilterTensorMultiple(RowFilterBank, ColFilterBank)
</pre><pre class="codeoutput">
FilterBank2d = 

1x4 struct array with fields:

    row_filter
    row_start_pt
    col_filter
    col_start_pt

</pre><h2>2D Dual Tree Filter Banks<a name="13"></a></h2><div><ol><li>DualTreeFilter2d.m</li></ol></div><pre class="codeinput">[FS_FilterBanks, FilterBanks] = DualTreeFilter2d
FilterBanks{1}{1}   <span class="comment">% 2D filter bank (1 lowpass + 3 highpass), use tree 1 filter bank for both rows and columns.</span>
</pre><pre class="codeoutput">
FS_FilterBanks = 

    {1x2 cell}    {1x2 cell}


FilterBanks = 

    {1x2 cell}    {1x2 cell}


ans = 

1x4 struct array with fields:

    row_filter
    row_start_pt
    col_filter
    col_start_pt

</pre><p>Both <i>FS_FilterBanks</i> and <i>FilterBanks</i> are 2x2 cells. There is one 2D filter bank in each cell. (Each 2D filter bank satisfies PR condition by itself.) <i>FS_FilterBanks</i> is for first stage filter banks. <i>FilterBanks</i> are for later stages.</p><p><i>FilterBanks{i}{j}</i> is the filter bank generated by: using Tree i filter bank for rows, Tree j filter bank for columns.</p><h2>2D Dual Tree Split Highpass Filter Banks<a name="15"></a></h2><div><ol><li>DualTreeFilter2d_SplitHipass.m</li></ol></div><p>The same as DualTreeFilter2d.m above, for multiple hipass filters in each tree.</p><pre class="codeinput">[FS_FilterBanks, FilterBanks] = DualTreeFilter2d_SplitHipass
</pre><pre class="codeoutput">
FS_FilterBanks = 

    {1x2 cell}    {1x2 cell}


FilterBanks = 

    {1x2 cell}    {1x2 cell}

</pre><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2014a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Filters
% _*Author: Chenzhe Diao*_
% 
% Implementation of Dual Tree filters and help functions to construct
% filters, including 2D filters constructed by tensor product structure.
%


%% Data Structure of filters
% 
% * 1D Filter:
%
%       filter1d.filter   :  array of filter
%       filter1d.start_pt :  filter array starting point
%
% * 2D Filter:
%
%       filter2d.row_filter:    array of row filter
%       filter2d.col_filter:    array of col filter
%       filter2d.row_start_pt:  row filter array starting point
%       filter2d.col_start_pt:  col filter array starting point
% 
% * Filter Bank
%
%     Implemented as an array of filers:  [lowpass, highpass1, highpass2, ...]. 
%     We always put lowpass at the first.
%
%       1x(s+1) struct array with fields:
%
%           filter
%           start_pt
%           
%       1x(s+1) struct array with fields:
%
%           row_filter
%           row_start_pt
%           col_filter
%           col_start_pt

%% 1D Haar Filter
% 
[HaarLow, HaarHigh] = Haar1d

%% CQF
% Generate highpass filter from lowpass filter in CQF pair.
%
% $$b_n = (-1)^{n+1} a_{1-n}$$
% 

HaarHigh = CQF(HaarLow)

%% Convolution of 2 1D filters
%

f = convfilter1d( HaarLow, HaarHigh )

%% 1D Dual Tree Filter Banks
% The Filter Banks given by Selesnick
%
% # FirstStageFilter1d.m
% # FirstStageFilterShift1d.m
% # Tree1Filter1d.m
% # Tree2Filter1d.m
%

%%
% * First Stage Filter Bank for Tree 1:

FS_Filter = FirstStageFilter1d;
lowpass = FS_Filter(1)
highpass = FS_Filter(2)

%%
% * First Stage Filter Bank for Tree 2. The lowpass is a shifted version of Tree
% 1.

FS_Filter2 = FirstStageFilterShift1d;
lowpass = FS_Filter2(1)
highpass = FS_Filter2(2)

%%
% * Later filter bank for Tree 1:

Filter1 = Tree1Filter1d;
lowpass = Filter1(1)
highpass = Filter1(2)

%%
% * Later filter bank for Tree 2:

Filter2 = Tree2Filter1d;
lowpass = Filter2(1)
highpass = Filter2(2)

%% Generate 2D Filter/Filter Bank by Tensor Product
% 
% # FilterTensor.m
% # FilterTensorMultiple.m

%%
% * Generate a 2D filter with 2 1D filters

[RowFilter, ColFilter] = Haar1d;
filter2d = FilterTensor( RowFilter, ColFilter )

%%
% * Generate 2D filter bank with 2 1D filter banks

RowFilterBank = Tree1Filter1d;
ColFilterBank = Tree2Filter1d;
FilterBank2d = FilterTensorMultiple(RowFilterBank, ColFilterBank)

%% 2D Dual Tree Filter Banks
% # DualTreeFilter2d.m
%

[FS_FilterBanks, FilterBanks] = DualTreeFilter2d
FilterBanks{1}{1}   % 2D filter bank (1 lowpass + 3 highpass), use tree 1 filter bank for both rows and columns.

%%
% Both _FS_FilterBanks_ and _FilterBanks_ are 2x2 cells. There is one 2D
% filter bank in each cell. (Each 2D filter bank satisfies PR condition by
% itself.) _FS_FilterBanks_ is for first stage filter banks. _FilterBanks_
% are for later stages.
%
% _FilterBanks{i}{j}_ is the filter bank generated by: using Tree i filter
% bank for rows, Tree j filter bank for columns.

%% 2D Dual Tree Split Highpass Filter Banks
% # DualTreeFilter2d_SplitHipass.m
%
% The same as DualTreeFilter2d.m above, for multiple hipass filters in each tree.
%

[FS_FilterBanks, FilterBanks] = DualTreeFilter2d_SplitHipass

















##### SOURCE END #####
--></body></html>